{"version":3,"file":"main.js","mappings":"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","sources":["webpack://assignment-problem-frontend/./node_modules/electron-cgi/connection-builder.js","webpack://assignment-problem-frontend/./node_modules/electron-cgi/connection.js","webpack://assignment-problem-frontend/./node_modules/electron-cgi/index.js","webpack://assignment-problem-frontend/./node_modules/electron-cgi/request.js","webpack://assignment-problem-frontend/./node_modules/electron-cgi/tab-separated-input-stream-parser.js","webpack://assignment-problem-frontend/./node_modules/uuid/lib/bytesToUuid.js","webpack://assignment-problem-frontend/./node_modules/uuid/lib/rng.js","webpack://assignment-problem-frontend/./node_modules/uuid/v4.js","webpack://assignment-problem-frontend/external \"child_process\"","webpack://assignment-problem-frontend/external \"crypto\"","webpack://assignment-problem-frontend/external \"electron\"","webpack://assignment-problem-frontend/external \"events\"","webpack://assignment-problem-frontend/external \"path\"","webpack://assignment-problem-frontend/external \"url\"","webpack://assignment-problem-frontend/webpack/bootstrap","webpack://assignment-problem-frontend/webpack/runtime/compat get default export","webpack://assignment-problem-frontend/webpack/runtime/define property getters","webpack://assignment-problem-frontend/webpack/runtime/hasOwnProperty shorthand","webpack://assignment-problem-frontend/webpack/runtime/make namespace object","webpack://assignment-problem-frontend/./src/main.ts"],"sourcesContent":["const { spawn } = require('child_process');\nconst { Connection } = require('./connection');\n\nexports.ConnectionBuilder = function ConnectionBuilder() {\n    var spawnArguments = null;\n    this.connectTo = (command, ...args) => {\n        spawnArguments = {\n            command,\n            args\n        };\n        return this;\n    };\n    this.build = () => {\n        if (!spawnArguments) {\n            throw new Error('Use connectTo(pathToExecutable, [arguments]) to specify to which executable to connect');\n        }\n        const executable = spawn(spawnArguments.command, spawnArguments.args);\n \n        if (!executable.pid)\n            throw new Error(`Could not start ${spawnArguments.command}. Are you sure you have the right path?`);\n \n        executable.on('exit', (code) => {\n            if(this.handleOnExit){\n                this.handleOnExit(code);\n            }\n            console.log(`Connection to ${spawnArguments.command} was terminated (code: ${code})`)\n        });\n        executable.stderr.on('data', data => {\n            if(this.handleOnStderr)\n            {\n                this.handleOnStderr(data);\n            }\n            process.stdout.write('\\x1b[7m'); //invert terminal colors\n            process.stdout.write(data);\n            process.stdout.write('\\x1b[0m'); //reset colors\n        });\n        return new Connection(executable.stdin, executable.stdout);\n    };\n        \n    this.handleOnStderr = null;\n    this.handleOnExit = null;\n    this.onStderr = function(handler) {\n        this.handleOnStderr = handler\n        return this;\n    }\n    this.onExit = function (handler) {\n        this.handleOnExit = handler;\n        return this;\n    }         \n}\n","const Request = require('./request');\nconst TabSeparatedInputStreamParser = require('./tab-separated-input-stream-parser');\n\n/** @param {import('stream').Writable} outStream */\nexports.Connection = function Connection(outStream, inStream) {\n    const responseHandlersQueue = [];\n    const requestHandlersQueue = [];\n\n    const inputStreamParser = new TabSeparatedInputStreamParser();\n\n    inStream.setEncoding('utf8');\n    inStream.on('data', (chunk) => {\n        inputStreamParser.addPartial(chunk);\n    });\n\n    inStream.on('close', () => {\n        if (this.onDisconnect) {\n            this.onDisconnect();\n        }\n    });\n\n    inputStreamParser.onResponse(response => {\n        const responseIds = responseHandlersQueue.map(r => r.id);\n        if (responseIds.indexOf(response.id) !== -1) {\n            responseHandlersQueue.splice(responseIds.indexOf(response.id), 1)[0].onResponse(null, response.result);\n        }\n    });\n\n    inputStreamParser.onError(errorResponse => {\n        const responseIds = responseHandlersQueue.map(r => r.id);\n        if (responseIds.indexOf(errorResponse.requestId) !== -1) {\n            responseHandlersQueue.splice(responseIds.indexOf(errorResponse.requestId), 1)[0].onResponse(JSON.parse(errorResponse.error));\n        }\n    })\n\n    inputStreamParser.onRequest(request => {\n        const requestType = request.type;\n        requestHandlersQueue.filter(rh => rh.type === requestType).forEach(handlerContainer => {\n            const requestHandler = handlerContainer.onRequest;\n            const resultArgs = requestHandler(request.args)\n            sendResponse(request.id, resultArgs);\n        });\n    });\n\n    const sendResponse = (requestId, resultArgs) => {\n        if (!outStream.writable) return; //stream was closed    \n        outStream.write(`{\"type\": \"RESPONSE\", \"response\": ${JSON.stringify({\n            id: requestId,\n            result: JSON.stringify(resultArgs === undefined ? null : resultArgs)\n        })}}\\t`);\n    }\n\n    const sendRequest = (request, onResponse) => {\n        if (!outStream.writable) return;\n        outStream.write(`{\"type\": \"REQUEST\", \"request\": ${JSON.stringify(request)}}\\t`);\n        if (onResponse) {\n            responseHandlersQueue.push({\n                id: request.id,\n                onResponse\n            });\n        }\n    };\n\n    this.onDisconnect = null;\n\n    this.send = (type, args = {}, onResponse = null) => {\n        if (typeof args === 'function' && onResponse === null) { //if there's only one argument and it's a function assume it's the callback\n            onResponse = args;\n            args = {}\n        }\n        if (onResponse === null) {\n            return new Promise((resolve, reject) => {\n                sendRequest(new Request(type, args), (err, result) => {\n                    if (err)\n                        reject(err)\n                    else\n                        resolve(result)\n                });\n            });\n        } else {\n            sendRequest(new Request(type, args), onResponse);\n        }\n    };\n\n    this.on = (type, onRequest) => {\n        requestHandlersQueue.push({ type, onRequest })\n    }\n\n    this.close = () => {\n        outStream.end();\n    };\n}\n","const { ConnectionBuilder } = require(\"./connection-builder\");\n\nmodule.exports = {\n    ConnectionBuilder\n};","const uuidv4 = require('uuid/v4');\n\nfunction Request(type, args) {\n    this.type = type;\n    this.id = uuidv4();\n    this.args = JSON.stringify(args);\n}\n\nmodule.exports = Request;","const { EventEmitter } = require('events');\n\nfunction TabSeparatedInputStreamParser() {\n    const messageEmitter = new EventEmitter();\n    let streamInput = '';\n\n    this.addPartial = streamContent => {        \n        streamInput += streamContent;\n        while (streamInput.indexOf('\\t') !== -1) {\n            const messageStr = streamInput.substring(0, streamInput.indexOf('\\t'));\n            streamInput = streamInput.substring(streamInput.indexOf('\\t') + 1);\n            let message = null;\n            try {\n                message = JSON.parse(messageStr);\n            } catch (e) {\n                throw new Error(`Invalid incoming JSON: ${messageStr}`);\n            }\n            if (message.type === 'RESPONSE') {\n                messageEmitter.emit('response',message.response);\n            }else if (message.type === 'REQUEST') {\n                messageEmitter.emit('request', message.request);\n            }else if (message.type === 'ERROR'){\n                messageEmitter.emit('error', message)\n            }\n        }\n    };\n\n    this.onResponse = handleResponseCallback => {\n        messageEmitter.on('response', handleResponseCallback);\n    };\n\n    this.onError = handleErrorCallback => {\n        messageEmitter.on('error', handleErrorCallback);\n    };\n\n\n    this.onRequest = handleRequestCallback => {\n        messageEmitter.on('request', handleRequestCallback);\n    };\n}\n\nmodule.exports = TabSeparatedInputStreamParser;","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"electron\");","module.exports = require(\"events\");","module.exports = require(\"path\");","module.exports = require(\"url\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const url = require(\"url\");\nconst path = require(\"path\");\nconst { ConnectionBuilder } = require(\"electron-cgi\");\n\nimport { app, BrowserWindow } from \"electron\";\n\nlet window: BrowserWindow | null;\n\nconst createWindow = () => {\n  window = new BrowserWindow({\n    width: 800,\n    height: 600,\n    webPreferences: {\n      nodeIntegration: true,\n      contextIsolation: false,\n      enableRemoteModule: true,\n    },\n  });\n\n  window.loadURL(\n    url.format({\n      pathname: path.join(__dirname, \"index.html\"),\n      protocol: \"file:\",\n      slashes: true,\n    })\n  );\n\n  window.on(\"closed\", () => {\n    window = null;\n  });\n};\n\napp.on(\"ready\", createWindow);\n\napp.on(\"window-all-closed\", () => {\n  if (process.platform !== \"darwin\") {\n    app.quit();\n  }\n});\n\napp.on(\"activate\", () => {\n  if (window === null) {\n    createWindow();\n  }\n});\n\n// let connection = new ConnectionBuilder()\n//   .connectTo(\"dotnet\", \"run\", \"--project\", \"../../AssignmentProblem/AssignmentProblem/\")\n//   .build();\n\n// connection.onDisconnect = () => {\n//     console.log(\"lost\");\n//     connection = new ConnectionBuilder().connectTo('dotnet', 'run', '--project', \"../Core/\").build();\n// };\n\n//  connection.send('greeting', 'John', (error: any, response: any) => {\n//     if (error) {\n//         console.log(error); //serialized exception from the .NET handler\n//         return;\n//     }\n//     window.webContents.send(\"greeting\", response);\n//     console.log(response);\n//     connection.close();\n// });\n"],"names":["url","require","path","ConnectionBuilder","app","BrowserWindow","window","createWindow","width","height","webPreferences","nodeIntegration","contextIsolation","enableRemoteModule","loadURL","format","pathname","join","__dirname","protocol","slashes","on","process","platform","quit"],"sourceRoot":""}